---
title: "Tarea 2 - Estad铆stica Actuarial II"
author: 
  - Estudiantes
  - Luis Fernando Amey Apuy - C20470
  - Javier Antonio Hern谩ndez Navarro - C13674
  - Sof铆a Bocker Brenes - C11102
date: "`r Sys.Date()`"
output: 
  rmdformats::robobook:
    highlight: tango
---

# Librer铆as

```{r}
# install.packages("pacman")
pacman::p_load(
  ggplot2, 
  lubridate,
  tidyverse,
  plotly
)
```

# Pregunta 1

## Algoritmo de Integraci贸n por Montecarlo
Usando un Algoritmo de Integraci贸n por Montecarlo estime la siguiente integral: 
$$\int_0^1 \dfrac{e^{-x^2}}{1+x^2} \ dx$$ 
Usando la funci贸n _integrate_ de R, estime que el error de aproximaci贸n sea menor a $10^{-3}$, y mu茅strelo, esta funci贸n integrate utiliza el m茅todo de Simpson


# Pregunta 2

## a) Esperanza de $f_L(L)$
El valor esperado de una funci贸n de p茅rdida en una p贸liza de seguros, donde la p茅rdida $L$, sigue una distribuci贸n exponencial con par谩metro $\lambda = 1$. Queremos estimar el valor esperando de la siguiente funci贸n: 
$$E[L] = \int_0^\infty Lf_L(L) \ dL$$
Donde $f_L(L)$ es la funci贸n de densidad de la distribuci贸n de la p茅rdida $L$

## b) Programar $f_L(L)$
Programe la funci贸n de p茅rdida $f_L(L)$ seg煤n el enunciado

## c) Muestreo por importancia
Para muestrear valores extremos de nuestra muestra, podemos usar una distribuci贸n auxiliar
$$g(L) \sim N(3,4)$$
Implemente un muestreo por importancia con esta funci贸n auxiliar, para $n = 10^4$ e indique el valor esperado de la p茅rdida de los valores extremos, usando como semilla _set.seed(54321)_

# Pregunta 3
La siguiente muestra indica el tiempo en d铆as entre cada accidente laboral de una empresa:
$$2.72, 1.93, 1.76, 0.49, 6.12, 0.43, 4.01, 1.71, 2.01, 5.96$$
Se sabe que los tiempos entre accidentes poseen una distribuci贸n exponencial de par谩metro $\lambda$. Usaremos como funci贸n a priori de $\lambda$ una distribuci贸n gamma de par谩metros (2,1)

## a) Valor estimado de 
Indique el valor estimado de $\lambda$, utilizando el algoritmo de Aceptaci贸n y Rechazo.

```{r}
mas_acc_lab <- c(2.72, 1.93, 1.76, 0.49, 6.12, 0.43, 4.01, 1.71, 2.01, 5.96)
s_acc_lab <- sum(mas_acc_lab)
n_acc_lab <- length(mas_acc_lab)
m_acc_lab <- s_acc_lab/n_acc_lab
```

Puesto as铆, nuestra funci贸n a posteriori de $\lambda$ es una $\Gamma(12, 28.14)$

Al maximizar nuestra funci贸n $\frac{f(x)}{g(x)}$, tomando a $g \sim exp(1)$
```{r}
maxc <- 10/27.14
c <- dgamma(maxc, 11, 27.14)
```

```{r}
U <- runif(10^4)
x <- rexp(10^4,1)
ngen <- length(x)
dgamma1 <- Vectorize(function(x) dgamma(x, 11, 27.14))
DIB <- dgamma1(x)
for(i in 1:10^4){
  while((U[i]*c) >= (DIB[i])){ 
    U[i] <- runif(1)
    x[i] <- rexp(1)
    DIB[i] <- dgamma1(x[i])
    ngen <- ngen+1
  }
}
(lambda <- mean(x))
```

## b) Distribuci贸n de 
Construya el histograma para la distribuci贸n de $\lambda$

```{r}
fig <- ggplot(data.frame(x = x), aes(x = x)) +
  geom_histogram(aes(y = after_stat(density), color = "Histograma"), bins = 40, fill = "lightblue", alpha = 0.5) +
  stat_function(fun = function(x) dgamma(x, 11, 28.14), aes(color = "Densidad Te贸rica"), size = 1.5) +
  labs(title = "Histograma de Lambda", x = "x", y = "Density", color = "Leyenda", fill = " ") +
  scale_color_manual(values = c("cyan", "black")) +
  theme(legend.position = 'bottom') +
  theme_minimal() 
fig %>% ggplotly()
```


## c) Generaciones
Indique el n煤mero de generaciones, n煤mero medio de generaciones y proporci贸n de rechazos de la estimaci贸n realizada

```{r}
{cat("N煤mero de generaciones = ", ngen)
cat("\nN煤mero medio de aceptados = ", ngen/10^4)
cat("\nProporci贸n de rechazos = ", 1-10^4/ngen, "\n")}
```

## d) Intervalo de credibilidad
Determine un intervalo de credibilidad al 99% para el par谩metro $\lambda$ estimado

```{r}
quantile(x, c(0.005, 0.995))
```

## e) Hip贸tesis
Aceptar铆a o rechazar铆a la hip贸tesis que $\lambda = 0.5$, basados en el intervalo de credibilidad anterior. 

Podemos aceptar esta hip贸tesis ya que se encuentra dentro del intervalo de credibilidad anterior. Solo la rechazamos cuando tenemos un intervalo de credibilidad de 75%
```{r}
quantile(x, c(0.175, 0.825))
```

# Pregunta 4
Sea $f(x) = \exp\left(\frac{\sin(10x)}{10\cos(x)}\right)$, para $x \in [0,10]$

## a) Algoritmo de recalentamiento simulado
Utilizando el algoritmo de recalentamiento simulado estime el m铆nimo global en [0,10], con valor inicial en 5

```{r}
resim <- function(f, alpha=0.5, s0=0, niter,mini=-Inf,maxi=Inf) {
  s_n <- s0
  estados<-rep(0,niter)
  iter_count <- 0
  for (k in 1:niter) {
    estados[k]<-s_n
    T <- (1 - alpha)^k
    s_new <- rnorm(1, s_n, 1)
    if(s_new<mini){s_new=mini}
    if(s_new>maxi){s_new=maxi}
    dif <- f(s_new) - f(s_n)
    if (dif < 0) {
      s_n = s_new
    } else {
      random <- runif(1,0,1)
      if (random < exp(-dif/T)) {
      s_n <- s_new
      }
    }
    iter_count <- iter_count + 1
  }
  return(list(r=s_n,e=estados))
}
```


```{r}
f <- function(x) exp(sin(10*x)/(10*cos(x)))
Resultado <-resim(f,0.1,5,10000,0,10) # 10e3 puesto se quedaba varado en algunas
Resultado$r
```


## b) Gr谩fico de estados 
Grafique el resultado de los estados donde estuvo la cadena de la estimaci贸n del punto a.

```{r, echo=FALSE}
par(mfrow = c(1, 2))
plot(f, xlim = c(0, 10))
plot(Resultado$e)
par(mfrow = c(1, 1))
```


# Pregunta 5
Dada una muestra de siniestros observados por periodo:
$$4,2,5,6,3,4,7,5,6,4$$
Suponemos que el n煤mero de siniestros en cada periodo sigue una distribuci贸n de Poisson con un par谩metro $\lambda$. Queremos estimar el par谩metro $\lambda$ usando el Algoritmo de *Metropolis-Hastings*, usaremos como funci贸n a priori de $\lambda$ una distribuci贸n gamma de par谩metros (3,2)

## a) Algoritmo de Metropolis-Hastings
Construya un algoritmo de Metropolis-Hastings que muestree el par谩metro $\lambda$, a partir de los datos suministrados con $n = 10^4$

```{r}
# Muestra de siniestros observados
siniestros <- c(4, 2, 5, 6, 3, 4, 7, 5, 6, 4)

# Par谩metros para la funci贸n Gamma (priori)
alpha <- 3
beta <- 2

# Funci贸n de densidad de Poisson para los siniestros
verosimilitud_log <- function(lambda, datos) {
  sum(dpois(datos, lambda, log = TRUE))
}

# Funci贸n de densidad de la priori Gamma
priori_log <- function(lambda) {
  dgamma(lambda, shape = alpha, rate = beta, log = TRUE)
}

# Funci贸n posterior
posterior_log <- function(lambda, datos) {
  verosimilitud_log(lambda, datos) + priori_log(lambda)
}

# Algoritmo de Metropolis-Hastings
metropolis_hastings <- function(datos, n_iteraciones = 10000) {
  cadena_lambda <- numeric(n_iteraciones)
  cadena_lambda[1] <- runif(1, min = min(datos), max = max(datos))
  aceptaciones <- 0
  
  for (i in 2:n_iteraciones) {
    lambda_actual <- cadena_lambda[i - 1]
    lambda_propuesto <- rnorm(1, mean = lambda_actual, sd = 1)
    
    if (lambda_propuesto > 0) {
      log_alpha <- posterior_log(lambda_propuesto, datos) - posterior_log(lambda_actual, datos)
      alpha <- exp(log_alpha)
      
      if (runif(1) < alpha) {
        cadena_lambda[i] <- lambda_propuesto
        aceptaciones <- aceptaciones + 1
      } else {
        cadena_lambda[i] <- lambda_actual
      }
    } else {
      cadena_lambda[i] <- lambda_actual
    }
  }
  
  list(cadena = cadena_lambda, tasa_aceptacion = aceptaciones / n_iteraciones)
}

# Ejecuta el algoritmo con n = 10000
resultado <- metropolis_hastings(siniestros, n_iteraciones = 10000)
cadena_lambda <- resultado$cadena
tasa_aceptacion <- resultado$tasa_aceptacion
```


## b) Histograma
Grafique la distribuci贸n (histograma) de la muestra MCMC del algoritmo.

```{r}
hist(cadena_lambda, breaks = 50, freq = FALSE, 
     main = "Histograma de lambda (MCMC)", 
     xlab = expression(lambda), col = "salmon")
```


## c) Traceplot
Gr谩fique el Traceplot de muestra MCMC del algoritmo

```{r}
plot(cadena_lambda, type = "l", 
     main = "Traceplot de la muestra MCMC", 
     ylab = expression(lambda), xlab = "Iteraciones")
```


## d) Autocorrelaci贸n
El gr谩fico de Autocorrelaci贸n de la muestra MCMC del algoritmo.

```{r}
acf(cadena_lambda, main = "Autocorrelaci贸n de la muestra MCMC")
```


## e) Convergencia de la media
El gr谩fico de la convergencia (promedios erg贸dicos) de la media de la muestra MCMC del algoritmo.

```{r}
promedios <- cumsum(cadena_lambda) / (1:length(cadena_lambda))
plot(promedios, type = "l", 
     main = "Convergencia (Promedios erg贸dicos)", 
     ylab = "Promedio acumulado de lambda", xlab = "Iteraciones")
```


## f) Aceptaci贸n
La tasa de aceptaci贸n del algoritmo.

```{r}
cat("Tasa de aceptaci贸n:", tasa_aceptacion)
```

